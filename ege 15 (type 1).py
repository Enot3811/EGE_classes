"""
Обозначим через m & n поразрядную конъюнкцию неотрицательных целых чисел m и n.
Так, например, 14 & 5 = 1110(2) & 0101(2) = 0100(2) = 4. Для какого наименьшего неотрицательного целого числа А формула

x & 29 ≠ 0 → (x & 17 = 0 → x & А ≠ 0)

тождественно истинна (т.е. принимает значение 1 при любом неотрицательном целом значении переменной x)?
"""


# В целом, в этих задачах можно не задумываться о значении для range
# часто встречается, что люди пишут 1000
# Но вообще здесь следуюет брать то число, после увеличения которого уже ничего не поменяется
# То есть 29 это 11101, а значит на операцию & с ним будут влиять только последние 5 бит любого числа
# Например 31: 11111 & 11101
# А если брать число больше, то 29 просто дополнится нулевым старшим битом,
# что просто обнулит старшие биты большего числа.
# Например 54: 110110 & 011101
# Поэтому для x берём 32 как крайнюю точку

# Для А такая же логика, но уже в сравнении с х.
# Если у х максимум 5 бит, то для А также не имеет смысла иметь больше 5 бит,
# так как они просто обнулятся



# В остальном обычная задача перебора
# Для какого А выражение всегда истино?
# Перебираем все А
for a in range(32):  # range(1000) тоже обычно срабатывает
    
    # и для каждого А перебираем все возможные значения х
    for x in range(32):
        # Для каждого х смотрим, чтобы выражение было истино
        # (not для того, чтобы инвертировать ложь в истину, чтобы if сработал)
        if not ((x & 29 != 0) <= ((x & 17 == 0) <= (x & a != 0))):
            # Если это выражение оказалось ложным
            # то обрываем текущий цикл, так как уже понятно, что текущее А не подошло
            break
    # else у цикла срабатывает тогда, когда он полность отработал (без break)
    # что в текущем контексте означает, что для всех х выражение было истино
    else:
        print(a)
        # Так как ищем наименьшее А, то дальнейший поиск не нужен
        break
