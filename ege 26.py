"""
#26 27423
Системный администратор раз в неделю создаёт архив пользовательских файлов.
Однако объём диска, куда он помещает архив, может быть меньше,
чем суммарный объём архивируемых файлов.
Известно, какой объём занимает файл каждого пользователя.

По заданной информации об объёме файлов пользователей и свободном объёме на архивном диске
определите максимальное число пользователей, чьи файлы можно сохранить в архиве,
а также максимальный размер имеющегося файла, который может быть сохранён в архиве,
при условии, что сохранены файлы максимально возможного числа пользователей.

В первой строке входного файла находятся два числа: S — размер свободного места на диске
(натуральное число, не превышающее 10 000)
и N— количество пользователей (натуральное число, не превышающее 1000).
В следующих N строках находятся значения объёмов файлов каждого пользователя
(все числа натуральные, не превышающие 100), каждое в отдельной строке.

Запишите в ответе два числа: сначала наибольшее число пользователей,
чьи файлы могут быть помещены в архив, затем максимальный размер имеющегося файла,
который может быть сохранён в архиве, при условии,
что сохранены файлы максимально возможного числа пользователей.

Пример входного файла:

100 4
80
30
50
40

При таких исходных данных можно сохранить файлы максимум двух пользователей.
Возможные объёмы этих двух файлов 30 и 40, 30 и 50 или 40 и 50.
Наибольший объём файла из перечисленных пар — 50, поэтому ответ для приведённого примера:

2 50
"""

# Читаем файл, получаем список со строками
with open('input_files\\26_27423.txt') as f:
    data_lines = f.readlines()

# В первой строке информация о памяти и количестве пользователей.
# Берём её, разделяем (split по умолчанию делит по пробелам)
# Получаем строковые представления двух чисел
s, n = data_lines[0].split()
s = int(s) # Конвертируем в числовой формат
n = int(n) # n здесь в целом не обязательно, так как есть len
data_lines.pop(0) # Удалить эту строку, чтобы не мешала

# Конвертируем все строки в списки в числа
for i in range(n):
    data_lines[i] = int(data_lines[i])

# Необходимо сохранить наибольшее количество пользователей
# Чтобы это сделать, начнём сохранение сначала с самых маленьких
# и по нарастанию
data_lines.sort()  # Для этого отсортируем список

saved_files = 0  # Здесь будем накапливать сохранённые файлы
num_files = 0  # Здесь будем их считать
for i in range(n):
    current_file = data_lines[i]
    # Если текущий файл можно вместить
    if saved_files + current_file < s:
        # Добавляем его размер к сохранённым
        saved_files += current_file
        # Наращиваем счётчик
        num_files += 1
    # Если текущий файл уже не влазит, то заканчиваем
    else:
        break

# На данный момент мы вместили максимально возможное количество файлов,
# и самый большой файл - последний, то есть сейчас его размер лежит в current_file
# Однако если сделать print(saved_files, s), то можно увидеть, что мы заняли
# не всю возможную память
# Значит вместо текущего последнего самого большого файла можно попробовать
# подыскать другой, ещё больший файл, который сможет заполнить как можно больше
# оставшегося места

mem_dif = s - saved_files
# Для этого продолжим перебор файлов с того, на котором остановились
for j in range(i, n):
    # Если другой больший файл может поместиться,
    if data_lines[j] - current_file < mem_dif:
        # то сохраняем его как наибольший
        biggest_file = data_lines[j]
    # Если больший файл занял как раз всё место,
    elif data_lines[j] - current_file == mem_dif:
        # то сохраняем его и останавливаем поиск
        biggest_file = data_lines[j]
        break
    # Если же текущий больший файл не вмещается,
    else:  # data_lines[j] - current_file > mem_dif:
        # то просто оканчиваем поиск, а в качестве ответа берём значение
        # прошлого большего файла, который сейчас в biggest_file
        break

print(num_files, biggest_file)


"""
#26 35484
В текстовом файле записан набор натуральных чисел, не превышающих 109.
Гарантируется, что все числа различны.
Необходимо определить, сколько в наборе таких пар чётных чисел,
что их среднее арифметическое тоже присутствует в файле,
и чему равно наибольшее из средних арифметических таких пар.

Первая строка входного файла содержит целое число N — общее количество чисел в наборе.
Каждая из следующих N строк содержит одно число.

В ответе запишите два целых числа: сначала количество пар, затем наибольшее среднее арифметическое.

Пример входного файла:
6
3
8
14
11
2
17

В данном случае есть две подходящие пары: 8 и 14 (среднее арифметическое 11),
14 и 2 (среднее арифметическое 8). В ответе надо записать числа 2 и 11.
"""

# Читаем все строки, получаем список data_lines с str числами
with open('input_files\\26_35484.txt') as f:
    data_lines = f.readlines()

# Первая строка содержит количество строк
# Можем воспользоваться, или использовать len(data_lines)
# n_lines = int(data_lines[0])
# В любом случае от строки лучше избавиться перед дальнейшими действиями
data_lines.pop(0)

# Переводим все str числа в int
for i in range(len(data_lines)):
    data_lines[i] = int(data_lines[i])

# Необходимо перебрать все пары чисел в списке
# i будет отвечать за индекс первого число в паре, j за индекс второго
# Из-за вложенности цикла получается, что для одного значения i будут перебраны
# все значения j от i не включительно до конца списка
# Таким образом можно перебрать все пары
# Можно проверить как оно работает на каком нибудь списке поменьше
# data_lines = [1, 2, 3, 4, 5]

# set или множество.
# Содержит в себе какие-либо элементы как и список, однако их устройство
# коренным образом отличается
# Здесь нас интересует лишь 2 его свойства
# 1) Он чрезвычайно эффективен при поиске элементов в нём
# 2) Он способен содержать только уникальные элементы
# 1-е свойство поможет не зависнуть на пол часа при выполнении программы из-за
# тяжести операции in при выполнении на списке.
# Про 2-е свойство просто необходимо помнить, когда конвертируешь список в set.
# В данном задании сказано, что в списке всё равно только уникальные числа,
# значит ничего не потеряется
set_data_lines = set(data_lines)

max_mean = 0
num_means = 0
for i in range(len(data_lines)):
    for j in range(i + 1, len(data_lines)):
        # print(data_lines[i], data_lines[j])
        
        # Требуют пары чётных чисел
        if data_lines[i] % 2 == 0 and data_lines[j] % 2 == 0:
            # Считаем среднее
            mean = (data_lines[i] + data_lines[j]) // 2

            # Проверяем, есть ли он среди исходных чисел
            # if mean in data_lines:  # Долго
            if mean in set_data_lines:  # Быстро
                # Если да, то засчитываем его
                num_means += 1
                
                # и проверяем, не обновит ли он максимум
                if mean > max_mean:
                    max_mean = mean
print(num_means, max_mean)


"""
#26 40742
Во многих компьютерных системах текущее время хранится в формате «UNIX-время» —
количестве секунд от начала суток 1 января 1970 года.

В одной компьютерной системе проводили исследование загруженности.
Для этого в течение месяца с момента UNIX-времени 1633046400 фиксировали
и заносили в базу данных моменты старта и финиша всех процессов, действовавших в этой системе.

Вам необходимо определить, какое наибольшее количество процессов выполнялось
в системе одновременно на неделе, начавшейся в момент UNIX-времени 1633305600,
и в течение какого суммарного времени (в секундах) выполнялось такое наибольшее количество процессов.


Первая строка входного файла содержит целое число N — общее количество процессов за весь период наблюдения.
Каждая из следующих N строк содержит 2 целых числа:
время старта и время завершения одного процесса в виде UNIX-времени.
Все данные в строках входного файла отделены одним пробелом.

Если в качестве времени старта указан ноль, это означает,
что процесс был активен в момент начала исследования.
Если в качестве времени завершения указан ноль, это означает,
что процесс не завершился к моменту окончания исследования.

При совпадающем времени считается, что все старты
и завершения процессов происходят одновременно, в начале соответствующей секунды.
В частности, если время старта одного процесса совпадает с временем завершения другого
и других стартов и завершений в этот момент нет, то количество активных процессов в этот момент не изменяется.

В ответе запишите два целых числа: сначала максимальное количество процессов,
которые выполнялись одновременно на неделе, начиная с момента UNIX-времени 1633305600,
затем суммарное количество секунд, в течение которых на этой неделе выполнялось такое максимальное количество процессов.
"""

with open('input_files/26_40742.txt') as f:
    data_lines = f.readlines()    
# n_lines = int(data_lines[0])
data_lines.pop(0)  # Убираем лишнюю строку, чтобы потом на неё не отвлекаться

# Стартовое время дано
start_time = 1633305600
# Чтобы узнать конечное, нужно узнать сколько секунд длится неделя
week_in_seconds = 7 * 24 * 60 * 60
end_time = start_time + week_in_seconds

# Логика решения следующая:
# Создадим список, в котором каждая ячейка будет обозначать то,
# насколько изменяется количество процессов в соответствующую единицу времени
# Например, если processes_changing[5] == 2, то значит в 5-ю секунду
# от времени старта запустилось 2 новых процесса.
# Если число отрицательное, то наоборот, в эту единицу времени количество
# активных процессов уменьшилось
# Изначально создаём список с нулями на каждую секунду исследуемой недели.
processes_changing = [0] * 604800
# print(len(processes_changing), processes_changing)

# Проходим по процессам
for line in data_lines:
    # Каждая строка - 2 числа через пробел
    # print(line)
    # Разделим её с помощью split
    start_process, end_process = line.split()
    # Конвертируем строки в числа
    start_process = int(start_process)
    end_process = int(end_process)

    # Если процесс начался до недели, и не закончился до недели или в её начало
    if start_process <= start_time and (end_process > start_time or end_process == 0):
        # То вкинем его в самое начало недели
        processes_changing[0] += 1
    
    # Если же он начался после начала, то надо проверить в границах ли недели
    elif start_process >= start_time and start_process <= end_time:
        # Если да, то добавляем его к той секунде, когда он начался
        
        # В списке индексы означают относительное время
        # То есть начало недели - 0
        # В то время как начало недели на самом деле start_time
        # Необходимо перевести абсолютное время в относительное
        # processes_changing[start_process] - out of range error
        processes_changing[start_process - start_time] += 1

    # Если процесс закончился в рамках недели
    if end_process >= start_time and end_process <= end_time:
        # то отнимаем 1 от соответствующей секунды
        processes_changing[end_process - start_time] -= 1

count = 0  # Счётчик активных процессов в текущую единицу времени
max_process = 0  # Максимальное количество одновременных процессов
sum_time = 0  # Время, сколько продержалось максимальное количество процессов
# Проходим по созданному списку
for i in range(len(processes_changing)):
    # Каждый элемент этого списка изменяет текущее количество процессов
    count += processes_changing[i]
    # Если текущих процессов больше, чем максимально замеченных раннее
    if count > max_process:
        # То обновляем максимум
        max_process = count
        # а раз новый максимум, то и время считать придётся заново
        sum_time = 0
    # Если текущее количество процессов равно максимальному,
    # то текущую секунду надо добавить к времени работы максимального количества процессов
    if count == max_process:
        sum_time = sum_time + 1

print(max_process, sum_time)
