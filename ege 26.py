"""
#26 27423
Системный администратор раз в неделю создаёт архив пользовательских файлов.
Однако объём диска, куда он помещает архив, может быть меньше,
чем суммарный объём архивируемых файлов.
Известно, какой объём занимает файл каждого пользователя.

По заданной информации об объёме файлов пользователей и свободном объёме на архивном диске
определите максимальное число пользователей, чьи файлы можно сохранить в архиве,
а также максимальный размер имеющегося файла, который может быть сохранён в архиве,
при условии, что сохранены файлы максимально возможного числа пользователей.

В первой строке входного файла находятся два числа: S — размер свободного места на диске
(натуральное число, не превышающее 10 000)
и N— количество пользователей (натуральное число, не превышающее 1000).
В следующих N строках находятся значения объёмов файлов каждого пользователя
(все числа натуральные, не превышающие 100), каждое в отдельной строке.

Запишите в ответе два числа: сначала наибольшее число пользователей,
чьи файлы могут быть помещены в архив, затем максимальный размер имеющегося файла,
который может быть сохранён в архиве, при условии,
что сохранены файлы максимально возможного числа пользователей.

Пример входного файла:

100 4
80
30
50
40

При таких исходных данных можно сохранить файлы максимум двух пользователей.
Возможные объёмы этих двух файлов 30 и 40, 30 и 50 или 40 и 50.
Наибольший объём файла из перечисленных пар — 50, поэтому ответ для приведённого примера:

2 50
"""

# Читаем файл, получаем список со строками
with open('input_files\\26_27423.txt') as f:
    data_lines = f.readlines()

# В первой строке информация о памяти и количесте пользователей.
# Берём её, разделяем (split по умолчанию делит по пробелам)
# Получаем строковые представления двух чисел
s, n = data_lines[0].split()
s = int(s) # Конвертируем в числовой формат
n = int(n) # n здесь в целом не обязательно, так как есть len
data_lines.pop(0) # Удалить эту строку, чтобы не мешала

# Конвертируем все строки в списки в числа
for i in range(n):
    data_lines[i] = int(data_lines[i])

# Необходимо сохранить наибольшее количество пользователей
# Чтобы это сделать, начнём сохранение сначала с самых маленьких
# и по нарастанию
data_lines.sort()  # Для этого отсортируем список

saved_files = 0  # Здесь будем накапливать сохранённые файлы
num_files = 0  # Здесь будем их считать
for i in range(n):
    current_file = data_lines[i]
    # Если текущий файл можно вместить
    if saved_files + current_file < s:
        # Добавляем его размер к сохранённым
        saved_files += current_file
        # Нарасчиваем счётчик
        num_files += 1
    # Если текущий файл уже не влазит, то заканчиваем
    else:
        break

# На данный момент мы вместили максимально возможное количество файлов,
# и самый большой файл - последний, то есть сейчас его размер лежит в current_file
# Однако если сделать print(saved_files, s), то можно увидеть, что мы заняли
# не всю возможную память
# Значит вместо текущего последнего самого большого файла можно попробовать
# подыскать другой, ещё больший файл, который сможет заполнить как можно больше
# оставшегося места

mem_dif = s - saved_files
# Для этого продолжим перебор файлов с того, на котором остановились
for j in range(i, n):
    # Если другой больший файл может поместиться,
    if data_lines[j] - current_file < mem_dif:
        # то сохраняем его как наибольший
        bigest_file = data_lines[j]
    # Если больший файл занял как раз всё место,
    elif data_lines[j] - current_file == mem_dif:
        # то сохраняем его и останавливаем поиск
        bigest_file = data_lines[j]
        break
    # Если же текущий больший файл не вмещается,
    else:  # data_lines[j] - current_file > mem_dif:
        # то просто оканчиваем поиск, а в качестве ответа берём значение
        # прошлого большего файла, который сейчас в bigest_file
        break

print(num_files, bigest_file)
