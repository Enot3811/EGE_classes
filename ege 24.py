"""
#24 27421
Текстовый файл состоит не более чем из 10^6 символов X, Y и Z.
Определите максимальное количество идущих подряд символов,
среди которых каждые два соседних различны.

Для выполнения этого задания следует написать программу.
Ниже приведён файл, который необходимо обработать с помощью данного алгоритма.
"""

# Открываем файл на чтение
# Для удобства можно поместить файл вместе с текущим файлом .py,
# чтобы не приходилось писать директории в пути.
# В windows вместо / использовать \\
with open('input_files/24_27421.txt', 'r') as f:
    # Читаем с помощью .read, так как последовательность символов в данном
    # номере дана в виде одной строки без переносов.
    symbols = f.read()

# Задача состоит в поиске самоей длинной подстроки в строке
# по условию неравенства соседних символов

# Заводим переменную для поиска максимума
max_len = 0
# и переменную, в которой будем хранить длину текущей подстроки,
# удовлетворяющей условию
current_len = 1

# Проходим по строке, при этом смотрим на пары символов как в 17-м номере
for i in range(len(symbols) - 1):
    # Если текущий символ не совпадает со следующем,
    # то длина подстроки становится на 1 больше
    if symbols[i] != symbols[i + 1]:
        current_len += 1
    # Если же следующий символ уже не подходит,
    # то текущая подстрока заканчивается
    else:
        # Смотрим, не оказалась ли она новым максимумом
        max_len = max(current_len, max_len)
        # Сбрасываем счётчик обратно,
        # чтобы со следующего символа начать проверять следующую подстроку
        current_len = 1

print(max_len)


"""
#24 55820
Текстовый файл состоит не более, чем из 1200000 символов английского алфавита.

Определите максимальное количество идущих подряд символов,
среди которых символы Q, R, S в различных комбинациях (с учётом повторений) не стоят рядом.

Для выполнения этого задания следует написать программу.
"""

with open('input_files/24_55820.txt', 'r') as f:
    symbols = f.read()

max_len = 0
current_len = 1

for i in range(len(symbols) - 1):
    # Если текущий или следующий символ не QRS, то в этой паре QRS не стоят рядом
    if symbols[i] not in 'QRS' or symbols[i + 1] not in 'QRS':
        current_len += 1
    else:
        max_len = max(current_len, max_len)
        current_len = 1

print(max_len)

# Мне показалось, что условие в этом задании хоть и короткое,
# но, возможно, до него не сразу можно догадаться.
# Вероятно, изначально в голову придёт что-то более прямолинейное
# symbols[i] not in 'QRS' or symbols[i] in 'QRS' and symbols[i + 1] not in 'QRS' or symbols[i + 1] in 'QRS' and symbols[i] not in 'QRS':
# Текущий символ QRS, или текущий символ QRS, но следующий не QRS, или следующий символ QRS, но текущий не QRS
# то есть перебор всех удовлетворяющих нас случаев
