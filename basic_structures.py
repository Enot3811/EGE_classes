"""
В этом файле я опишу основные конструкции, которые используются в большинстве языков программирования.
Для того, чтобы писать программы, нужно мыслить в рамках этих конструкций,
пытаться оформить данную задачу с помощью них.
"""


# Типичный примеры задачи:
# Дана коллекция элементов (список, строка, массив, файл и т.д.)
# Посчитайте какую-то величину (сумму, количество или какую-то сторонню величину)
# Так как большинство действий нельзя применить к самой коллекции,
# но можно применить к её элементам, необходимо обрабатывать каждый элемент самостоятельно

l = [1, 4, -6, 2]
summa = 0
# Проходим по списку
for i in range(len(l)):
    # Берём каждый элемент отдельно и прибавляем к сумме
    summa += l[i]
print('Сумма равна:', summa)


# Или если мы хотим считать величину только каки-то избранных элементов
# Тогда каждый i-й элемент нужно фильтровать с помощью условия
l = [1, 4, -6, 2]
summa = 0
for i in range(len(l)):
    # Берём каждый элемент отдельно
    # И перед тем как использовать его, проверяем подходит ли он
    if l[i] > 0:
        summa += l[i]
print('Сумма положительных чисел равна:', summa)



# Например, задача с черепахой
# Дана фигура, лежащая где-то внутри области -100 < x < 100; -100 < y < 100
# необходимо посчитать количество точек внутри фигуры

# Выглядит как 2 цикла, но смысл тот же самый: дана коллекция точек, надо посчитать количество подходящих
count = 0
for x in range(-100, 100):
    for y in range(-100, 100):
        # Какая-то функция, которая проверяет принадлежность к фигуре
        if in_figure(x, y):
            count += 1
print('Количество точек в фигуре:', count)




# Бывают такие моменты, когда мы не знаем, сколько элементов будет в коллекции
# Например, идёт случайная последовательность чисел, оканчивающаяся нулём.
# Необходимо найти количество чисел, кратных 5 и сумму чисел, кратных 3
from random import randint

count = 0
summa = 0

# В случае с while часто приходится заводить переменную, описанную в его условии до самого цикла,
# чтобы избежать ошибки

# Можно воспользоваться тем же способом заполнения, как в самом цикле
current_num = randint(0, 100)

# А можно приравнять её к какому-то фальшивому значению, которое точно не повлияет на ответ
current_num = -1

while current_num != 0:
    if current_num % 5 == 0:
        count += 1
    elif current_num % 3 == 0:
        summa += current_num
    current_num = randint(0, 100)
print('Количество кратных 5:', count)
print('Сумма кратных 3:', summa)


# Или есть более костыльный метод, с while True и break
# Опишу его, потому как порой бывает легче сделать так, чем как выше
while True:
    current_num = randint(0, 100)

    if current_num == 0:
        break
    elif current_num % 5 == 0:
        count += 1
    elif current_num % 3 == 0:
        summa += current_num
print('Количество кратных 5:', count)
print('Сумма кратных 3:', summa)

# ВАЖНО! В этих примерах всегда нужно думать о том, где расположить строку,
# влияющую на отслеживаемую переменную (current_num = randint)
# То есть, например, в первом случае если мы берём способ первоначальной инициализации как randint,
# то для первого значения сделаются все действия, а потом в конце итерации создаётся новое значение,
# которое перейдёт на следующую интерацию.
# Если взять -1, то 1-я итерация пройдёт вхолостую. Бывает, что это влияет на итоговый ответ.



# Например 5-я задача с бинарными числами
# Мы перебираем числа не по range, по условию до тех пор, пока что-то там не найдём

num = 0
result = 0 # Закидываем фильшивое значение
while result <= 57:
    num += 1 # Тот самый момент, когда надо подумать о расположении этой строки
    # Если поместить её здесь, то для этого num посчитается result,
    # и если result остановит цикл, то значение num будет с ЭТОЙ итерации, а не со следующей
    # продолжение объяснения в конце итерации


    bnum = bin(num)[2:]
    # Здесь можно увидеть пример описываемых выше задач
    # Дана коллекция числе, посчитать сумму
    summa = 0
    for i in range(len(bnum)):
        # Только здесь приходится ещё произвести над элементом дополнительное действие с int
        summa += int(bnum[i])

    bnum += str(summa % 2)
    result = int(bnum, 2)

    # num += 1
    # Если разместить эту строку здесь, то result будет с этой итерации, а num уже для следующей
    # Здесь это влияет на ответ, так как в случае остановки цилка в ответ пойдёт num со СЛЕДУЮЩЕЙ итерации,
    # которой уже не будет

print('Подходящее число:', num)
