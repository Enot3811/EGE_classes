"""
#25 27422
Напишите программу, которая ищет среди целых чисел, принадлежащих числовому отрезку [174457; 174505],
числа, имеющие ровно два различных натуральных делителя, не считая единицы и самого числа.
Для каждого найденного числа запишите эти два делителя в два соседних столбца на экране с новой строки
в порядке возрастания произведения этих двух делителей.
Делители в строке также должны следовать в порядке возрастания.

Например, в диапазоне [5; 9] ровно два различных натуральных делителя имеют числа 6 и 8,
поэтому для этого диапазона вывод на экране должна содержать следующие значения:

2 3
2 4
"""

for i in range(174457, 174506):
    # Для каждого перебираемого числа будем сохранять найденные делители
    divisors = []
    # Перебираем все числа, на которые число может делиться
    # range(2, i) тоже сойдёт, но будет немного дольше работать
    # Логика же здесь в том, что перебирать стоит лишь числа от 2 до половины
    # делимого, так как за половиной поделить нацело уже не получится.
    for j in range(2, i // 2 + 1):
        if i % j == 0:  # Если делится нацело
            divisors.append(j)  # Добавляем в делители
            # Если по мере добавления окажется, что делителей уже больше 2
            if len(divisors) > 2:
                # то бросаем текущее число
                break
    # Если же цикл закончился, то break не было
    else:
        # Проверяем, сколько нашлось делителей у текущего числа
        if len(divisors) == 2:
            # Просят определённый формат вывода, поэтому распаковываем список
            print(divisors[0], divisors[1])


print()
"""
#25 57432
Назовём маской числа последовательность цифр,
в которой также могут встречаться следующие символы:
1)  символ «?» означает ровно одну произвольную цифру;
2)  символ «*» означает любую последовательность цифр произвольной длины;
в том числе «*» может задавать и пустую последовательность.

Например, маске 123*4?5 соответствуют числа 123405 и 12300405.

Среди натуральных чисел, не превышающих 10^8, найдите все числа,
соответствующие маске 12??1*56, делящиеся на 317 без остатка.

В ответе запишите в первом столбце таблицы все найденные числа в порядке возрастания,
а во втором столбце — соответствующие им результаты деления этих чисел на 317.
"""

# Максимальное числов 10^8
# 100000000
# Если вместо звёздочки будет 2 символа, то число окажется больше максимального
# 12??1**56
# Значит там может быть только 1 и 0 символов
#  12??1*56
#   12??156

numbers = []
# ? - число от 0 до 9
for i in range(10):
    for j in range(10):
        # Отдельно обработаем случай, где 0 символов вместо *
        num = int('12' + str(i) + str(j) + '156')
        if num % 317 == 0:
            numbers.append(num)
        
        # Случаи, где 1 символ вместо *
        for k in range(10):
            num = int('12' + str(i) + str(j) + '1' + str(k) + '56')
            if num % 317 == 0:
                numbers.append(num)

# Отсортируем на всякий случай
numbers.sort()
for num in numbers:
    print(num, num // 317)


print()
"""
#25 39254
Пусть M(N) — произведение 5 наименьших различных натуральных делителей натурального числа N,
не считая единицы. Если у числа N меньше 5 таких делителей, то M(N) считается равным нулю.

Найдите 5 наименьших натуральных чисел, превышающих 500 000 000, для которых 0 < M(N) < N.
В ответе запишите найденные значения M(N) в порядке возрастания соответствующих им чисел N.
"""

n_results = 0
n = 500000001  # Начинаем перебор с указанного числа
# Перебираем до тех пор, пока количество результатов меньше 5
while(n_results < 5):

    m_n = 1  # Здесь будем хранить произведение делителей числа
    count_m_n = 0  # Счётчик найденных делителей текущего числа n
    # Поиск делителей как в первой задаче
    for j in range(2, n // 2 + 1):
        if n % j == 0:  # Если делится нацело
            m_n *= j
            count_m_n += 1
            # Если после домножения на очередной найденный множитель мы превысили n,
            # то бросаем перебор
            if m_n >= n:
                break
            # Если же m_n всё ещё меньше n, а количество делителей - 5,
            # то выводим это число, нарасщиваем счётчик ответов
            # и бросаем перебор текущего числа, так как для него уже нашли
            elif count_m_n == 5:
                print(m_n)
                n_results += 1
                break

    # Так как это while, а не for, счётчик здесь приходится делать вручную
    n += 1

# Поиск здесь оказался довольно долгим. Подождать около минуты
